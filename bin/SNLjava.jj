/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
 options{  JDK_VERSION = "1.5";  static = true;}
PARSER_BEGIN(SNL)
public class SNL{

  public boolean verbose;
    public static void main(String args []) {
	if (args.length == 0) {
	    System.out.println("No input given");
	    //  SNL snlParser = new SNL(System.in);
	    return;
	} else if(args.length <= 2){
		System.out.println("Reading from file:" + args[0] + "...");
		//Checks verbose option
		if(args.lenght == 2 && Integer.toString(args[1]) == 1)
			this.verbose = true;
		else
			this.verbose = false;
		//Starts the parser
		try {
	    	SNL parser = new SNL(new java.io.FileInputStream(args[0]));
	    	parser.compilation_unit();
			System.out.println("Parsing complete");
		//Catchs Exceptions
	    } catch (java.io.FileNotFoundException e) {
	    	System.out.println("The File " + args[0] + " has not been found");
	    	return;
	   	} catch (TokenMgrException e1) {
	    	System.out.println("Token Exception");
	    	return;
	 	} catch (ParseException e2) {
	    	System.out.println("Parsing Exception");
	    	return;
	   }
	    	
	} else {
	    System.out.println("Wrong number of parameters. Paramater 1: input file. Parameter 2 (optional): verbose (1,0)");
	    return;
	}

	//Parser begin
	
  }
}
/* Parser begin -EXAMPLE 1
	try {
      	parser.inicio();
      	parser.ReInit(new java.io.FileInputStream(args[0]));
      	parser.inicioSegundo();
		String archivo = args[0];
      	if(archivo.endsWith(".java"))
      		archivo = archivo.replace(".java","");
      	parser.generarCodigo(archivo+".as");
    	System.out.println("Completado parser");
    } catch (ParseException e) {
   		System.out.println("Errores"+ e.getMessage());
	} catch (java.io.FileNotFoundException e) {
		System.out.println("Fichero " + args[0] + " no encontrado");
		return;
	}
*/

/* Parser begin - EXAMPLE 2
	while (true){
	  System.out.println("Reading from standard input...");
	  System.out.println("Enter an expression in Structured Java Natual Language: ");
	  
	  try
	  {
	    switch (SNL.one_line())
	    {
	      case 0 : 
	      System.out.println("OK.");
	      break;
	      case 1 : 
	      System.out.println("Goodbye.");
	      break;
	      default : 
	      break;
	    }
	  }
	  catch (Exception e)
	  {
	    System.out.println("NOK.");
	    System.out.println(e.getMessage());
	    eg1.ReInit(System.in);
	  }
	  catch (Error e)
	  {
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	    break;
	  }
	}
*/PARSER_END(SNL)SKIP :{  " " | "\r" | "\t" | "\n"}

/* __ SSNL TOKENS __*/

TOKEN [IGNORE_CASE] : 
{
  	//Java reserved words
  < PACKAGE_MOD : "package" >
| < IMPORT_MOD : "import" >
| < ABSTRACT_MOD : "abstract" >
| < STATIC_MOD : "static" >
| < FINAL_MOD : "final" >
| < EXTENDS_MOD : "extends" >
| < IMPLEMENTS_MOD : "implements" >
  	//Begin-End tokens
| < CLASS : "class" >
| < END_CLASS : "end-class" >
| < CONSTRUCTOR : "constructor" >
| < END_CONSTRUCTOR : "end-constructor" >
| < METHOD : ("function" | "method") >
| < END_METHOD: ("end-function" | "end-method") >
| < VARIABLE : ("variable" |"variables") >
| < END_VARIABLE : ("end-variable" |"end-variables") >
	//Control - Loop Expressions| < IF : "if" >
| < ELSE : "else" >
| < THEN : "then" >
| < END_IF : "end-if" >
| < WHILE : "while" >
| < END_WHILE: "end-while" >
	//Expression constants| < INSTANCE_OF : "instance_of" >
| < NEW : "new" >
	//Array Bracket list
| < ARRAY_TOKEN : ("[" "]")* >				// Is allways optional !!
	//Action Verbs -EXTENSIBLE
| < ASSIGN_VERB : "save" | "store" >
| < ASSIGN_VERB_3rd : "saves" | "stores" >
| < CREATION_VERB : "create" | "define" >
| < CREATION_VERB_3rd : "creates" | "defines" >
| < CONTROL_VERB : "check" | "verify" >
| < CONTROL_VERB_3rd : "checks" | "verifies" >
| < PRINT_VERB : "print" >
| < PRINT_VERB_3rd : "prints" >
| < READ : "read" >
| < RETURN_VERB : "return" >
| < RETURN_VERB_3rd : "returns" >
	//Functional connectors
| < CLASS_METHOD_CONNECTOR : "."  >			//N0 connector. ClassToClass, ClassToMethod, MethodToMethod 
| < METHOD_STATEMENT_CONNECTOR : ":"  > 	//N1 connector. MethodToStatement. Will be optional
| < LIST_CONNECTOR: (",") >					//N2 connector. VariableToVariable, ParameterToParamenter
| < STATEMENT_CONNECTOR : ";" >				//N3 connector. StatementToStatement
	//Other Tokens
| < DOT_NOTATION: "->" >
| < A_THE : "a" | "the" | "an" >
| < TO  : "to" >
| < IN  : "in" >
	//Auxiliar connector (not needed), might not be used
| < AUXILIAR_CONNECTOR : ("in" "addition") | "also" >
}

/* __ COMPLEX TOKENS ADDED FROM THE GRAMMAR __ *///This might clarify the syntactical analyzer

TOKEN:
{
  < PACKAGE_STATEMENT: (< PACKAGE_MOD > < CLASS_ID > < STATEMENT_CONNECTOR >) > //STATEMENT_CONNECTOR is ";" if there is any problem it can be changed
  // IMPORT FUNCTION HAS BEEN DISABLED
| < VISIBILITY: (< PUBLIC_MOD >|< PRIVATE_MOD >|< PROTECTED_MOD >) >
| < TYPE : (< TYPE_SPECIFIER >< ARRAY_TOKEN >) >
| < TYPE_SPECIFIER: (< TYPE_SPECIAL >|< CLASS_ID >) > 
| < TYPE_SPECIAL: (< CHAR >|< BOOLEAN >|< BYTE >|< SHORT >|< INT >|< LONG >|< FLOAT >|< DOUBLE >) >
| < BOOLEAN_TOKEN: (< TRUE >|< FALSE >) >
| < EXPRESSION_MODIFIER: (< NULL >|< SUPER >|< THIS >) >
}

/* __ COMPLEX TOKENS __ */

TOKEN :
{
  	//Subjects 			// ====== CHANGED ====== // 
  < SUBJECT : (< I_SUBJECT > | < NORMAL_SUBJECT >) >
| < SUBJECT_3rd : (< THIRD_SUBJECT > | < OTHER_SUBJECT >) >
	//Comparison		// ====== CHANGED ====== // -- A comparator is to be used in any comparison situation. No other token must be used
| < COMPARATOR : ( < IS > < COMPARISON_EXPRESSION > < THAN > ) | ( < COMPARISON_SYMBOLS > ) >
	//Operation 		// ====== CHANGED ====== // -- An operator is to be used in any operation situation. No other token must be used
| < OPERATOR: (< OPERATION_EXPRESSION >|< OPERATION_SYMBOL >) >
	//Unary Operation 	// ====== CHANGED ====== // -- An unary operator is to be used in any unary operation situation. No other token must be used
| <UNARY_OPERATOR: (< UNARY_OPERATION_EXPRESSION >|< UNARY_OPERATION_SYMBOL >) >
	//Minus (Unary Operation)
| < MINUS : (< LANGUAGE_MINUS >|< SYMBOLIC_MINUS >) >
	//String union expression // ONLY SYMBOLIC "+"
| < PLUS : (< SYMBOLIC_PLUS >) >
	//Linkers			// ====== CHANGED ====== // -- A linker is to be used in any union situation (And, Or). No other token must be used
| < LINKER: (< LINKER_EXPRESSION >|< LINKER_SYMBOL >) >
	//Assign
| < EQUALS : (< LANGUAGE_EQUALS >|< SYMBOLIC_EQUALS >) >
	//Auxiliar Verbs
| < AUXILIAR_EXPRESSION: (< AUX_VERB > < TO >|< MODAL_VERB >) >
| < AUXILIAR_EXPRESSION3:  (< AUX_VERB_3rd > < TO >|< MODAL_VERB >) >
	//Identifiers
| < CLASS_ID: <CAP_LETTER> (<ID_ANY>)* >
| < ID : <ID_BEGIN> (<ID_ANY>)* >
	//Literals
| < INTEGER_LITERAL: < CONSTANT > (< FLOATING_POINT > < CONSTANT >)? > 	// Semantic analyzer must chech if it is an Integer, Float or Double
| < STRING_LITERAL: "\"" <STRING_VAL > "\"" >
| < CHAR_LITERAL: "\'" < CHAR_VAL > "\'" >
}

TOKEN: /*Complex Meta Tokens, for the special Tokens, Comparator, Operator and Linker*/
{
 	//Language Comparison 	  < #COMPARISON_EXPRESSION : < LANGUAGE_EQUALS_COMPARISON >|(< LANGUAGE_COMPARISON > (< LANGUAGE_OR >< LANGUAGE_EQUALS_COMPARISON >)? )>
| < #LANGUAGE_EQUALS_COMPARISON : (< LANGUAGE_EQUALS > | < LANGUAGE_NOT ><LANGUAGE_EQUALS > ) >
| < #LANGUAGE_COMPARISON : (< LANGUAGE_GREATER >|< LANGUAGE_SMALLER > ) >
	//Symbol Comparison
| < #COMPARISON_SYMBOLS: < SYMBOLIC_EQUALS_COMPARISON >|(< SYMBOLIC_COMPARISON > (< LANGUAGE_EQUALS_COMPARISON >)?) >
| < #SYMBOLIC_EQUALS_COMPARISON: (< BOOLEAN_EQUALS >|< SYMBOLIC_NOT ><SYMBOLIC_EQUALS >) >
| < #SYMBOLIC_COMPARISON: (< SYMBOLIC_GREATER >|< SYMBOLIC_SMALLER >) >
	//Operations
| < #OPERATION_EXPRESSION: (< LANGUAGE_PLUS >|< LANGUAGE_MINUS >|< LANGUAGE_TIMES >|< LANGUAGE_DIVIDES >) >
| < #OPERATION_SYMBOL: (< SYMBOLIC_PLUS >|< SYMBOLIC_MINUS >|< SYMBOLIC_TIMES >|< SYMBOLIC_DIVIDES >) >
	//Unary Operation
| < #UNARY_OPERATION_EXPRESSION: (< LANGUAGE_INCREMENT >|< LANGUAGE_DECREMENT >) >
| < #UNARY_OPERATION_SYMBOL: (< SYMBOLIC_INCREMENT >|< SYMBOLIC_DECREMENT >) >
	//Linker
| < #LINKER_EXPRESSION: (< LANGUAGE_AND >|< LANGUAGE_OR >) >
| < #LINKER_SYMBOL: (< SYMBOLIC_AND >|< SYMBOLIC_OR >) >
}

TOKEN [IGNORE_CASE] : /* Meta Tokens - Ignore Case */ /* EXTENSIBLE */
{
  	//Auxiliar Verbs -EXTENSIBLE
  < #AUX_VERB : "want" | "need" >
| < #AUX_VERB_3rd : "wants" | "needs" >
| < #MODAL_VERB : "shall" | "must" | "will" >
  	//Language Comparators
| < #LANGUAGE_NOT : "not" >
| < #LANGUAGE_GREATER : "greater" >
| < #LANGUAGE_SMALLER : "smaller" >
  	//Symbolic Comparators -- 
| < #SYMBOLIC_NOT : "!" >
| < #SYMBOLIC_GREATER : ">" >
| < #SYMBOLIC_SMALLER : "<" >
	//Language Operators
| < #LANGUAGE_MINUS : "minus" >
| < #LANGUAGE_PLUS : "plus" >
| < #LANGUAGE_TIMES : "times" >
| < #LANGUAGE_DIVIDES : "divides" >
	//Symbolic Operators
| < #SYMBOLIC_MINUS : "-" >
| < #SYMBOLIC_PLUS : "+" >
| < #SYMBOLIC_TIMES : "*" >
| < #SYMBOLIC_DIVIDES : "/" >
	//Assign
| < #LANGUAGE_EQUALS : "equals" >  
| < #SYMBOLIC_EQUALS : "=" > 
	//Language Unary Operators
| < #LANGUAGE_INCREMENT: "increment" >
| < #LANGUAGE_DECREMENT: "decrement" >
	//Symbolic Unary Operators
| < #SYMBOLIC_DECREMENT:"--" >
| < #SYMBOLIC_INCREMENT:"++" >
	//Language Linkers
| < #LANGUAGE_AND : "and" >
| < #LANGUAGE_OR : "or" >
	//Symbolic Linkers
| < #SYMBOLIC_OR : "||" >
| < #SYMBOLIC_AND: "&&" >
	//Boolean operator
| < #BOOLEAN_EQUALS: "==" >
	//Boolean Tokens
| < #TRUE : "true" >
| < #FALSE : "false" >
	//Expression modifiers
| < #NULL : "null" >
| < #SUPER : "super" >
| < #THIS : "this" >
  	//Subject
| < #NORMAL_SUBJECT : ("you" | "we" | "they") >
| < #THIRD_SUBJECT : ("he" | "she" | "it" ) >
| < #OTHER_SUBJECT : < A_THE > ("program" | "computer" | "machine") >
	//Others
| < #IS  : "is" >
| < #THAN  : "than" >
	//Visibility
| < #PUBLIC_MOD : "public" >
| < #PRIVATE_MOD : "private" >
| < #PROTECTED_MOD : "protected" >
	//Type names
//| < #STRING : "string" > -- STRING is considered as a CLASS_ID token, it must begin with Capital Letter
| < #CHAR : "char" >
| < #BOOLEAN : "boolean" >
| < #BYTE : "byte" >
| < #SHORT : "short" >
| < #INT : "int" >
| < #LONG : "long" > 		//must be disabled
| < #FLOAT : "float" >		//must be disable
| < #DOUBLE : "double" >
	//Floating point suffixes
} 

TOKEN : /*Meta tokens*/
{
  	//First person subject
  < #I_SUBJECT : "I" >
	//Identifiers
| < #CONSTANT : (< DIGIT >)+ >
| < #FLOATING_POINT: ". " >
	//Might cause problems with N0 separator
| < #DIGIT : [ "0"-"9" ] >
| < #CAP_LETTER : ([ "A"-"Z" ]) >
| < #ID_BEGIN : ([ "a" - "z" ] | "$" | "_") >
| < #ID_ANY : (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "$" | "_" ) >
| < #STRING_VAL: (< CHAR_VAL >)+ >
| < #CHAR_VAL: (~["\"","'"]) >
}

/* __ __ REMARKS & CHANGES __ __ */

/* __ SUBJECTS __ */
/* This is not necesary, it must be changed in the grammar*/
/* __ OPERATORS __ */
//this way of declaring the operators might be the solution for the LL(1) problem, it should also increase efficiency
//The syntactical analyzer only needs to call expression operator, logical operator or concatenation operator
//expression_operator(+,-,*,/,+=,-=,*=,/=, and any combination with natural language)
//logical_operator(<,>,=,!=,==,<=, >= and any combination with natural language)
//comparison_operator (||, &&, or)
//PARENTHESIS ARE NOT INCLUDED !!!!
/*It might be better that the syntactical analyzer is on charge of this part, allowing nested brackets*/
/* __ UNUSED TOKENS __*/
//TOKEN [IGNORE_CASE] :
//{  
// <VALUE_OF : ("the" "value" "of") >// <ASSIGN : ( < SYMBOLIC_EQUALS > | < LANGUAGE_EQUALS >< TO > ) >
// <COMPLEX_OPERATION : "complex" "operation" >
//}
/*__ __ -------------------- __ __*/

/* __ -_-Syntactical Analyzer-_- __*/


/*
 *Prepares the grammar import and packages statements (Extracted from Java Grammar)
 * 
 * //compilation_unit : PACKAGE_STATEMENT? IMPORT_STATEMENT* TYPE_DECLARATION+
 *
 *IMPORT_STATEMENTS has been disabled for simplicity
 *
 *	("package" CLASS_ID ";")? class_declaration+
 */
void compilation_unit():{ if(this.verbose) System.out.println("Start compilation_unit"); }
{
  (< PACKAGE_STATEMENT >)? (class_declaration())+}

/*
 *	creation_sentence? ("public"|"private"|"protected")? ("final"|"abstract")? "class" CLASS_ID field_declaration+ "end-class"
 */
void class_declaration():{ if(this.verbose) System.out.println("Starts class_declaration");}{
  (creation_sentence())? (< VISIBILITY >)? (< FINAL_MOD >|<ABSTRACT_MOD >)? < CLASS > < CLASS_ID > (field_declaration())+ < END_CLASS >}
/*
 *	"." creation_sentence? ("public"|"private"|"protected")? ("static")? ("final")? (constructor_declaration | method_declaration | variable_list)
 */
void field_declaration():
{ if(this.verbose) System.out.println("Starts field_declaration");}
{
  < CLASS_METHOD_CONNECTOR > (creation_sentence())? (< VISIBILITY >)? (< STATIC_MOD >)? (< FINAL_MOD >)? (constructor_declaration() | method_declaration() | variable_list())
}
/* __ CONSTRUCTOR, METHOD, VARIABLES (attributes) __ */
/*
 * The constructor must have only access modifiers
 *
 *	"constructor" ID parameter_list() ':' statement_list "end-constructor"
 */
void constructor_declaration():
{ if(this.verbose) System.out.println("Starts contructor_declaration");}
{
  < CONSTRUCTOR > < ID > parameter_list() < METHOD_STATEMENT_CONNECTOR > statement_list() < END_CONSTRUCTOR >
}

/*
 * ("method"|"function) ID '(' ( parameter ("," parameter)* )? ')' ':' statement_list ("end-method"|"end-funtion")
 */
void method_declaration():
{ if(this.verbose) System.out.println("Starts method_declaration");}
{
  < METHOD > < TYPE > < ID > < ARRAY_TOKEN > parameter_list() < METHOD_STATEMENT_CONNECTOR > statement_list() < END_METHOD >
}

/*
 * ("variable"|"variables") variable_declaration ("," variable_declaration)* ("end-variable"|"end-variables")
 */
void variable_list():
{ if(this.verbose) System.out.println("Starts variable_list");}
{
  < VARIABLE > variable_declaration() (< LIST_CONNECTOR > variable_declaration())* < END_VARIABLE >
}

/*
 * ("boolean" | "byte" | "int" |...| CLASS_ID) ID []* variable_init?
 */
void variable_declaration():
{ if(this.verbose) System.out.println("Starts variable_declaration");}
{
  < TYPE > < ID > < ARRAY_TOKEN > (variable_init())?
}

/*
 * ("equals" | "=") (expression | array_values)
 */
void variable_init():
{ if(this.verbose) System.out.println("Starts variable_init");}
{
  < EQUALS > variable_initializer()
}

/*
 * (expression | array_values)
 */
void variable_initializer():
{ if(this.verbose) System.out.println("Starts variable_initializer");}
{
  expression() | array_init()
}

/*
 * needed for local variables, called from statement
 * creation_sentence? ("boolean" | ... | CLASS_ID) variable_list
 */
void variable_declaration_statement():
{ if(this.verbose) System.out.println("Starts statement_list");}
{
  (creation_sentence())? < TYPE > variable_list()
}

/* __ STATEMENTS __ */

/*
 * statement (';' statement)*
 */
void statement_list():
{ if(this.verbose) System.out.println("Starts statement_list");}
{
  statement() (< STATEMENT_CONNECTOR > statement())*
}

/*
 * variable_list | expression | if_statement | while_statement | print_statement | read_statement | return_statement
 */
void statement():
{ if(this.verbose) System.out.println("Starts statement");}
{
  ( variable_declaration_statement() | expression() | if_statement() | while_statement() | print_statement() | return_statement() )
}

/* __ IF __ */

/*
 * control_sentence? if_expression statement_list else_expression* "end-if"
 */
void if_statement():
{ if(this.verbose) System.out.println("Starts if_statement");}
{
  (control_sentence())? if_expression() statement_list() (else_expression())* < END_IF >
}

/*
 * "if" '(' logical_expression ')' "then"
 */
void if_expression():
{ if(this.verbose) System.out.println("Starts if_expression");}
{
  < IF > "(" logical_expression() ")" < THEN >
}

/*
 * "else" if_expression? statement_list 
 */
void else_expression():
{ if(this.verbose) System.out.println("Starts else_expression");}
{
  < ELSE > (if_expression())? statement_list()
}

/* __ WHILE __ */

/*
 * "while" '(' logical_expression ')' "then" statement_list "end-while"
 *
 * This statement does not use any natural language expression
 *
 */
void while_statement():
{ if(this.verbose) System.out.println("Starts while_statement");}
{
  < WHILE > "(" logical_expression() ")" < THEN > statement_list() < END_WHILE >
}

/* __ PRINT __ */

/*
 * print_sentence '(' expression ')'
 */
void print_statement():
{ if(this.verbose) System.out.println("Starts print_statement");}
{
  print_sentence() "(" expression() ")" 
}

/* __ READ __ */

/*
 * read_sentence '(' expression ')'
 *
 * not yet implemented 
 */
//void read_statement():
//{ if(this.verbose) System.out.println("Starts read_statement");}
//{
//	 read_sentence() "(" expression() ")" 
//}

/* __ RETURN __ */

/*
 * return_sentence expression
 *
 * ÁÁÁ Semantic analyzer must check the return type !!!
 */
void return_statement():
{ if(this.verbose) System.out.println("Starts return_statement");}
{
  return_sentence() expression() 
}

/* __ EXPRESSIONS __*/

/* __ LOGICAL EXPRESSIONS __ */

/* comparison_expression | '(' comparison_expression ')' // allows nested brackets */
void logical_expression():
{ if(this.verbose) System.out.println("Starts logical_expression");}
{
  comparison_expression() | "(" comparison_expression() ")"
}

/* (expression ("=="|"!="|">"| ... |"equals"|"greater or equals"|...) expression) link_expression? */
void comparison_expression():
{ if(this.verbose) System.out.println("Starts comparison_expression");}
{
  (expression() < COMPARATOR > expression()) link_expression()
}

/* (( "||" | "&&") logical_expression)+ */
void link_expression():
{ if(this.verbose) System.out.println("Starts link_expression");}
{
  (< LINKER > logical_expression())*
}

/* __ EXPRESSION __ */

/*
 * numeric_expression | string_expression | casting_expression | creating_expression
 * | literal_expression | "null""this""super" | ID | READ |"("expression")"|compound_expression
 */
void expression():
{ if(this.verbose) System.out.println("Starts expression");}
{
  numeric_expression() | string_expression() | casting_expression() | creating_expression()
  | literal_expression() | < EXPRESSION_MODIFIER > | < ID > | < READ > | "(" expression() ")" | compound_expression() 
}

/* (("--", "decrement"...)|("minus", "-")) expression() ) | ( expression ("++", "increment"...)) | ( expression ("+","-", ..."plus","minus",...)expression)*/
void numeric_expression():
{ if(this.verbose) System.out.println("Starts numeric_expression");}
{
  ( (< UNARY_OPERATOR >|< MINUS >) expression() ) | ( expression() < UNARY_OPERATOR >) | ( expression() < OPERATOR > expression() )
}

/* expression "+" expression */
void string_expression():
{ if(this.verbose) System.out.println("Starts string_expression");}
{
   expression() < PLUS > expression()
}

/* '(' TYPE ')' expression */
void casting_expression():
{ if(this.verbose) System.out.println("Starts casting_expression");}
{
   "(" < TYPE_SPECIFIER > ")" expression()
}

/* NEW expression_specifier */
void creating_expression():
{ if(this.verbose) System.out.println("Starts creating_expression");}
{
   < NEW > expression_specifier()
}

/* (CLASS_ID (' argument_list ')') | (TYPE_SPECIAL '[' expression ']') | '(' expression ')' */
void expression_specifier():
{ if(this.verbose) System.out.println("Starts expression_specifier");}
{
   ( < CLASS_ID > "(" argument_list() ")" ) | (< TYPE_SPECIAL > "[" expression() "]") | "(" expression() ")"
}

/* CONSTANT ("." CONSTANT)? | \" (CHAR_LITERAL)+ \" | \' any char except (\n, \r \" \') \' */
void literal_expression():
{ if(this.verbose) System.out.println("Starts literal_expression");}
{
   < INTEGER_LITERAL > | < STRING_LITERAL > | < CHAR_LITERAL >
}

/* __ COMPUND EXPRESSION __*/

 /* expression ( '(' argument_list ')' | '[' expression ']' | DOT_NOTATION expression ) */
void compound_expression():
{ if(this.verbose) System.out.println("Starts compound_expression");}
{
   expression() ( argument_list() | "[" expression() "]" | < DOT_NOTATION > expression() )
}

/* __ NATURAL LANGUAGE __*/
//Natural language clauses are easily extensible in the token list

/* __ CREATION __ */

/*
 * ("I", "you"...) ("need to", "want to" | "must", "shall") ("create", "define") ("also", "in addition") ("a", "the")
 * ("I", "you"...) (("needs to", "wants to" | "must", "shall") ("create", "define") | ("creates", "defines"))("also", "in addition") ("a", "the")
 */
void creation_sentence():
{ if(this.verbose) System.out.println("Starts creation_sentence");}
{
 	(< SUBJECT > (< AUXILIAR_EXPRESSION >)? < CREATION_VERB > (< AUXILIAR_CONNECTOR >)? < A_THE >)
 	|(< SUBJECT_3rd > ( (< AUXILIAR_EXPRESSION > < CREATION_VERB >) | < CREATION_VERB_3rd >) (< AUXILIAR_CONNECTOR >)? < A_THE >)
}

/* __ CONTROL __ */

/*
 * ("I", "you"...) ("need to", "want to" | "must", "shall") ("check", "verify") ("also", "in addition")
 * ("I", "you"...) (("needs to", "wants to" | "must", "shall") ("check", "verify") | ("checks", "verifies"))("also", "in addition")
 */
void control_sentence():
{ if(this.verbose) System.out.println("Starts control_sentence");}
{
 	(< SUBJECT > (< AUXILIAR_EXPRESSION >)? < CONTROL_VERB > (< AUXILIAR_CONNECTOR >)? )
 	|(< SUBJECT_3rd > ( (< AUXILIAR_EXPRESSION > < CONTROL_VERB >) | < CONTROL_VERB_3rd >) (< AUXILIAR_CONNECTOR >)? )
}

/* __ PRINT __ */

/*
 * The print sentence is compulsory. But it can only contain the verb in order to simplify the sketched coding
 * ("print")
 * ("I", "you"...) ("need to", "want to" | "must", "shall") ("print") ("also", "in addition")
 * ("I", "you"...) (("needs to", "wants to" | "must", "shall") ("print") | ("prints"))("also", "in addition") 
 */
void print_sentence():
{ if(this.verbose) System.out.println("Starts print_sentence");}
{
  	( < PRINT_VERB > )
	| (< SUBJECT > (< AUXILIAR_EXPRESSION >)? < PRINT_VERB > (< AUXILIAR_CONNECTOR >)? )
 	| (< SUBJECT_3rd > ( (< AUXILIAR_EXPRESSION > < PRINT_VERB >) | < PRINT_VERB_3rd >) (< AUXILIAR_CONNECTOR >)? )
}

/* __ READ __ */

/*
 *The read sentence is not needed because it is encapsulated as an expression, so it has no sense to include a phrase in an expression and no phrases for the rest of them.
 *In order to read and store the result in a variable the next expression should be used:
 *
 *String s = read
 */

/* __ RETURN __ */

/*
 * The return sentence is compulsory. But it can only contain the verb in order to simplify the sketched coding.
 * It can only be used in third person, if it stands alone the regular form will be used "return" instead the third person "returns"
 *
 * ("return")
 * ("I", "you"...) (("needs to", "wants to" | "must", "shall") ("return") | ("returns"))
 */
void return_sentence():
{ if(this.verbose) System.out.println("Starts return_sentence");}
{
  	( < RETURN_VERB > )
 	| (< SUBJECT_3rd > ( (< AUXILIAR_EXPRESSION > < RETURN_VERB >) | < RETURN_VERB_3rd >) )
}

/* __ AUXILIAR EXPRESSIONS __ */ 

/*
 * A parameter list can allways be empty '()'
 *
 * 	(' ( parameter ("," parameter)* )? ')'
 *
 *	The parameter list could be:
 * 		() - empty
 *		(parameter) - one element
 *		(parameter ,parameter ,parameter) -n elements
 *  The parameter list cannot:
 *		(, parameter) - start with connector
 *		(parameter parameter) - have parameters without connector 
 */
void parameter_list():
{ if(this.verbose) System.out.println("Starts parameter_list");}
{
  "(" (parameter() (< LIST_CONNECTOR > parameter())*)? ")" 
}

/* TYPE ID ([])* */
void parameter():
{ if(this.verbose) System.out.println("Starts parameter");}
{
  < TYPE > < ID > < ARRAY_TOKEN >
}

/*
 * Is like a parameter list but with expressions instead parameters, 
 * much more complex
 *
 * (' ( expression ("," expression)* )? ')'
 */
void argument_list():
{ if(this.verbose) System.out.println("Starts argument_list");}
{
  "(" (expression() (< LIST_CONNECTOR > expression())*)? ")" 
}

/*
 * ("equals" | "=") (expression | array_values)
 *
 * It can produce a list of expression or array expressions:
 * 	expresssion
 *  { expression }
 *	{ expression ,expression }
 *	{ expression ,{ expression ,expression } ,expression}
 *
 */
void array_init():
{ if(this.verbose) System.out.println("Starts array_init");}
{
  "{" variable_initializer() (< LIST_CONNECTOR > variable_initializer())* "}" 
}





