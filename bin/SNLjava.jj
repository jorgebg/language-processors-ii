/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
 options{  JDK_VERSION = "1.5";  static = true;}
PARSER_BEGIN(SNL)
public class SNL{
    public static void main(String args []) throws ParseException {
	if (args.length == 0) {
	    System.out.println("No input given");
	    //  SNL snlParser = new SNL(System.in);
	    return;
	}else if(args.length == 1){		System.out.println("Reading from file:" + args[0] + "...");
		try {
	    	SNL snlParser = new SNL(new java.io.FileInputStream(args[0]));
	    } catch (java.io.FileNotFoundException e) {
	    	System.out.println("The File " + args[0] + " has not been found");
	    	return;
	   	}
	} else {
	    System.out.println("Wrong number of parameters");
	    return;
	}

	//Parser begin
	
  }
}
/* Parser begin -EXAMPLE 1
	try {
      	parser.inicio();
      	parser.ReInit(new java.io.FileInputStream(args[0]));
      	parser.inicioSegundo();
		String archivo = args[0];
      	if(archivo.endsWith(".java"))
      		archivo = archivo.replace(".java","");
      	parser.generarCodigo(archivo+".as");
    	System.out.println("Completado parser");
    } catch (ParseException e) {
   		System.out.println("Errores"+ e.getMessage());
	} catch (java.io.FileNotFoundException e) {
		System.out.println("Fichero " + args[0] + " no encontrado");
		return;
	}
*/

/* Parser begin - EXAMPLE 2
	while (true){
	  System.out.println("Reading from standard input...");
	  System.out.println("Enter an expression in Structured Java Natual Language: ");
	  
	  try
	  {
	    switch (SNL.one_line())
	    {
	      case 0 : 
	      System.out.println("OK.");
	      break;
	      case 1 : 
	      System.out.println("Goodbye.");
	      break;
	      default : 
	      break;
	    }
	  }
	  catch (Exception e)
	  {
	    System.out.println("NOK.");
	    System.out.println(e.getMessage());
	    eg1.ReInit(System.in);
	  }
	  catch (Error e)
	  {
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	    break;
	  }
	}
*/PARSER_END(SNL)SKIP :{  " " | "\r" | "\t" | "\n"}


/* __ SSNL TOKENS __*/

TOKEN [IGNORE_CASE] : 
{
  	//Java reserved words
  	< PACKAGE_MOD : "package" >
| < IMPORT_MOD : "import" >
| < PUBLIC_MOD : "public" >
| < PRIVATE_MOD : "private" >
| < PROTECTED_MOD : "protected" >
| < ABSTRACT_MOD : "abstract" >
| < STATIC_MOD : "static" >
| < FINAL_MOD : "final" >
| < EXTENDS_MOD : "extends" >
| < IMPLEMENTS_MOD : "implements" >
  	//Begin-End tokens
| < CLASS : "class" >
| < END_CLASS : "end-class" >
| < CONSTRUCTOR : "constructor" >
| < END_CONSTRUCTOR : "end-constructor" >
| < FUNCTION : ("function" | "method") >
| < END_FUNCTION: ("end-function" | "end-method") >
	//Control - Loop Expressions| <IF : "if" >
| < ELSE : "else" >
| < THEN : "then" >
| < END_IF : "end-if" >
| < WHILE : "while" >
| < END_WHILE: "end-while" >
| < VARIABLE : ("variable" |"variables") >
	//Expression constants| < INSTANCE_OF : "instance_of" >
| < NULL : "null" >
| < SUPER : "super" >
| < THIS : "this" >
| < NEW : "new" >
| < TRUE : "true" >
| < FALSE : "false" >
	//Type names
| < STRING : "string" >
| < CHAR : "char" >
| < BOOLEAN : "boolean" >
| < BYTE : "byte" >
| < SHORT : "short" >
| < INT : "int" >
| < LONG : "long" >
| < FLOAT : "float" >
| < DOUBLE : "double" >
	//Array Bracket list
| < ARRAY_TOKEN : ("[" "]")* >
	//Auxiliar Verbs -EXTENSIBLE
| <AUX_VERB : "want" | "need" >
| <AUX_VERB_3rd : "wants" | "needs" >
| <MODAL_VERB : "shall" | "must" | "will" >
	//Action Verbs -EXTENSIBLE
| <ASSIGN_VERB : "save" | "store" >
| <ASSIGN_VERB_3rd : "saves" | "stores" >
| <CREATION_VERB : "create" | "define" >
| <CREATION_VERB_3rd : "creates" | "defines" >
| <CONTROL_VERB : "check" | "verify" >
| <CONTROL_VERB_3rd : "checks" | "verifies" >
| <PRINT_VERB : "print" >
| <PRINT_VERB_3rd : "prints" >
| <RETURN_VERB : "returns" >
	//Word connectors
| <TO  : "to" >
| <IN  : "in" >
| <A_THE  : "a" | "an" | "the" >
	//Functional connectors
| < CLASS_METHOD_CONNECTOR : "."  >			//N0 connector. ClassToClass, ClassToMethod, MethodToMethod 
| < METHOD_STATEMENT_CONNECTOR : ":"  > 	//N1 connector. MethodToStatement. Will be optional
| <LIST_CONNECTOR: ("," | "and") >			//N2 connector. VariableToVariable, ParameterToParamenter
| < STATEMENT_CONNECTOR : ";" >				//N3 connector. StatementToStatement
	//Auxiliar connector (not needed), might not be used
| <AUX_CONNECTOR : ("in" "addition") | "also" >
	//Symbolic operators
| < SYMBOLIC_MINUS : "-" >
| < SYMBOLIC_PLUS : "+" >
| < SYMBOLIC_TIMES : "*" >
| < SYMBOLIC_DIVIDES : "/" >
| < SYMBOLIC_NOT : "!" >
| < SYMBOLIC_EQUALS : "=" >
| < SYMBOLIC_GREATER : ">" >
| < SYMBOLIC_SMALLER : "<" >
| < SYMBOLIC_OR : "||" >
| < SYMBOLIC_AND: "&&" >
	//Language Operators -- Actualy Add does not have a language operator
| < LANGUAGE_MINUS : "minus" >
| < LANGUAGE_PLUS : "plus" >
| < LANGUAGE_TIMES : "times" >
| < LANGUAGE_DIVIDES : "divides" >
| < LANGUAGE_NOT : "not" >
| < LANGUAGE_EQUALS : "equals" >
| < LANGUAGE_GREATER : "greater" >
| < LANGUAGE_SMALLER : "smaller" >
| < LANGUAGE_OR : "or" >
| < LANGUAGE_NUMERIC_INCREMENT: "increment" >
| < LANGUAGE_NUMERIC_DECREMENT: "decrement" >
	//Other Tokens
| < DOT_NOTATION: "->" >
| < A_THE : "a" | "the" | "an" >
}

/* __ COMPLEX TOKENS __ */

TOKEN :
{
  	//Subjects
  < SUBJECT : (< I_SUBJECT > | < NORMAL_SUBJECT >) >
| < SUBJECT_3 : (< THRD_SUBJECT > | < OTHER_SUBJECT >) >
	//Identifiers
| < CLASS_IDENTIFIER: <CAP_LETTER> (<ID_ANY>)* >
| < IDENTIFIER : <ID_BEGIN> (<ID_ANY>)* >
	//Constant
| < CONSTANT : (< DIGIT >)+ >
	//Comparison	// ====== CHANGED ====== //
| < COMPARE : ( < IS > < COMPARISON_EXPRESSIONS > < THAN > ) | ( < COMPARISON_SYMBOLS > ) >
}

TOKEN [IGNORE_CASE] : /* Meta Tokens - Ignore Case */ /* EXTENSIBLE */
{
  	//Subject
  < #NORMAL_SUBJECT : ("you" | "we" | "they") >
| < #THRD_SUJBJECT : ("he" | "she" | "it" ) >
| < #OTHER_SUBJECT : < A_THE > ("program" | "computer" | "machine") >
	//Others
| <#IS  : "is" >
| <#THAN  : "than" >
} 

TOKEN : /*Meta tokens*/
{
  	//First person subject
  < #I_SUBJECT : "I" >
	//Identifiers
| < #CAP_LETTER : ([ "A"-"Z" ]) >
| < #ID_BEGIN : ([ "a" - "z" ] | "$" | "_") >
| < #ID_ANY : (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "$" | "_" ) >
  	//Constant
| < #DIGIT : [ "0"-"9" ] >
}

/* __ SUBJECTS __ */
/* This is not necesary, it must be changed in the grammar*/

TOKEN : /* SUBJECT TOKENS */ /*==============__REAL CHANGE__==============*/
//{
//  < CREATION_SUBJECT : (< SUBJECT >) >
//| < CREATION_SUBJECT_3rd : (< SUBJECT_3 >) >
//| < CONTROL_SUBJECT : (< SUBJECT >) >
//| < CONTROL_SUBJECT_3rd : (< SUBJECT_3 >) >
//| < PRINT_SUBJECT : (< SUBJECT >) >
//| < PRINT_SUBJECT_3rd : (< SUBJECT_3 >) >
//| < RETURN_SUBJECT : (< A_THE > "function") | "it" >
//}

TOKEN [IGNORE_CASE] : /* VALUE OF */ /* NOT USED */
//{  
//<VALUE_OF : ("the" "value" "of") >
//}
/* __ ASSIGN __*/
TOKEN : /* ASSIGN SENTENCE */ /* NOT USED */
//{//  < ASSIGN : ( < SYMBOLIC_EQUALS > | < LANGUAGE_EQUALS >< TO > ) >
//} 

/* __ OPERATIONS __ */
TOKEN [IGNORE_CASE] : /* COMPLEX OPERATION EXPRESSION*/ /* NOT USED */
//{ 
// <COMPLEX_OPERATION : "complex" "operation" >
//}

/* __ OPERATORS __ */

//this way of declaring the operators might be the solution for the LL(1) problem, it should also increase efficiency
//The syntactical analyzer only needs to call expression operator, logical operator or concatenation operator
//expression_operator(+,-,*,/,+=,-=,*=,/=, and any combination with natural language)
//logical_operator(<,>,=,!=,==,<=, >= and any combination with natural language)
//comparison_operator (||, &&, or)
//PARENTHESIS ARE NOT INCLUDED !!!!

/*It might be better that the syntactical analyzer is on charge of this part, allowing nested brackets*/

TOKEN: /*OPERATORS*//*===CHANGED===*//*+++!LL(1)+++*/
//{//< EXPRESSION_OPERATOR: (< DOUBLE_EXPRESSION_OPERATOR >|< UNARY_EXPRESSION_OPERATOR >) >
//| <LOGICAL_OPERATOR: (< DOUBLE_LOGICAL_OPERATOR >|< UNARY_LOGICAL_OPERATOR >) >
//| < COMPARISON_OPERATOR(< OR >|< AND >) > 	// AND has not jet a language token
//}

TOKEN: /* CALCULATION EXPRESSION *//*===CHANGED====*//*+++!LL(1)+++*/ 
//{//< DOUBLE_EXPRESSION_OPERATOR: (< UNARY_EXPRESSION_OPERATOR > <EQUAL >) >
//| < UNARY_EXPRESSION_OPERATOR: (< MINUS >|< PLUS >|< TIMES >|< DIVIDES >) >
//}

TOKEN: /* LOGICAL EXPRESSION *//*===CHANGED===*//*+++!LL(1)+++*/ 
//{//< DOUBLE_LOGICAL_OPERATOR:((< EQUAL >|< NOT >|< UNARY_LOGICAL_OPERATOR >) < EQUAL >) //NOT is not standallone token, EQUAL is not standallone as a logical expression
//| <UNARY_LOGICAL_OPERATOR:(< GREATER >|< SMALLER >) >
//}

/* __ UNIVERSAL UNARY OPERATORS __ */

TOKEN [IGNORE_CASE]: /* UNARY OPERATORS DEFINITION *//*===CHANGED===*//*+++LL(1)DANGER++*/
//{
// < MINUS: (< SYMBOLIC_MINUS >|< LANGUAGE_MINUS >) >
//|  < PLUS: (< SYMBOLIC_PLUS >|< LANGUAGE_PLUS >) >
//|  < TIMES: (< SYMBOLIC_TIMES >|<LANGUAGE_TIMES >) >
//|  < DIVIDES: (< SYMBOLIC_DIVIDES >|<LANGUAGE_DIVIDES >) >
//|  < NOT: (< SYMBOLIC_NOT >|<LANGUAGE_NOT >) > 
//|  < EQUALS: (< SYMBOLIC_EQUALS >|<LANGUAGE_EQUALS >) >
//|  < GREATER:  (< SYMBOLIC_GREATER >|<LANGUAGE_GREATER >) >
//|  < SMALLER:  (< SYMBOLIC_SMALLER >|<LANGUAGE_SMALLER >) >//|  < OR: (< SYMBOLIC_OR >|<LANGUAGE_OR >) >
//|  < AND: (< SYMBOLIC_AND >) > //LANGUAGE AND MIGHT BE ADDED IN FUTURE
//}
/*----------------------------------*/


/

%%
 





