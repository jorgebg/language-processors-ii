/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
 options{  JDK_VERSION = "1.5";  static = true;}
PARSER_BEGIN(SNL)
public class SNL{

  public boolean verbose;
    public static void main(String args []) throws ParseException {
	if (args.length == 0) {
	    System.out.println("No input given");
	    //  SNL snlParser = new SNL(System.in);
	    return;
	} else if(args.length <= 2){
		System.out.println("Reading from file:" + args[0] + "...");
		//Checks verbose option
		if(args.lenght == 2 && Integer.toString(args[1]) == 1)
			this.verbose = true;
		else
			this.verbose = false;
		//Starts the parser
		try {
	    	SNL parser = new SNL(new java.io.FileInputStream(args[0]));
	    	parser.compilation_unit();
			System.out.println("Parsing complete");
		//Catchs Exceptions
	    } catch (java.io.FileNotFoundException e) {
	    	System.out.println("The File " + args[0] + " has not been found");
	    	return;
	   	}
	} else {
	    System.out.println("Wrong number of parameters. Paramater 1: input file. Parameter 2 (optional): verbose (1,0)");
	    return;
	}

	//Parser begin
	
  }
}
/* Parser begin -EXAMPLE 1
	try {
      	parser.inicio();
      	parser.ReInit(new java.io.FileInputStream(args[0]));
      	parser.inicioSegundo();
		String archivo = args[0];
      	if(archivo.endsWith(".java"))
      		archivo = archivo.replace(".java","");
      	parser.generarCodigo(archivo+".as");
    	System.out.println("Completado parser");
    } catch (ParseException e) {
   		System.out.println("Errores"+ e.getMessage());
	} catch (java.io.FileNotFoundException e) {
		System.out.println("Fichero " + args[0] + " no encontrado");
		return;
	}
*/

/* Parser begin - EXAMPLE 2
	while (true){
	  System.out.println("Reading from standard input...");
	  System.out.println("Enter an expression in Structured Java Natual Language: ");
	  
	  try
	  {
	    switch (SNL.one_line())
	    {
	      case 0 : 
	      System.out.println("OK.");
	      break;
	      case 1 : 
	      System.out.println("Goodbye.");
	      break;
	      default : 
	      break;
	    }
	  }
	  catch (Exception e)
	  {
	    System.out.println("NOK.");
	    System.out.println(e.getMessage());
	    eg1.ReInit(System.in);
	  }
	  catch (Error e)
	  {
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	    break;
	  }
	}
*/PARSER_END(SNL)SKIP :{  " " | "\r" | "\t" | "\n"}

/* __ SSNL TOKENS __*/

TOKEN [IGNORE_CASE] : 
{
  	//Java reserved words
  < PACKAGE_MOD : "package" >
| < IMPORT_MOD : "import" >
| < ABSTRACT_MOD : "abstract" >
| < STATIC_MOD : "static" >
| < FINAL_MOD : "final" >
| < EXTENDS_MOD : "extends" >
| < IMPLEMENTS_MOD : "implements" >
  	//Begin-End tokens
| < CLASS : "class" >
| < END_CLASS : "end-class" >
| < CONSTRUCTOR : "constructor" >
| < END_CONSTRUCTOR : "end-constructor" >
| < FUNCTION : ("function" | "method") >
| < END_FUNCTION: ("end-function" | "end-method") >
	//Control - Loop Expressions| < IF : "if" >
| < ELSE : "else" >
| < THEN : "then" >
| < END_IF : "end-if" >
| < WHILE : "while" >
| < END_WHILE: "end-while" >
| < VARIABLE : ("variable" |"variables") >
	//Expression constants| < INSTANCE_OF : "instance_of" >
| < NULL : "null" >
| < SUPER : "super" >
| < THIS : "this" >
| < NEW : "new" >
| < TRUE : "true" >
| < FALSE : "false" >
	//Type names
| < STRING : "string" >
| < CHAR : "char" >
| < BOOLEAN : "boolean" >
| < BYTE : "byte" >
| < SHORT : "short" >
| < INT : "int" >
| < LONG : "long" >
| < FLOAT : "float" >
| < DOUBLE : "double" >
	//Array Bracket list
| < ARRAY_TOKEN : ("[" "]")* >
	//Auxiliar Verbs -EXTENSIBLE
| < AUX_VERB : "want" | "need" >
| < AUX_VERB_3rd : "wants" | "needs" >
| < MODAL_VERB : "shall" | "must" | "will" >
	//Action Verbs -EXTENSIBLE
| < ASSIGN_VERB : "save" | "store" >
| < ASSIGN_VERB_3rd : "saves" | "stores" >
| < CREATION_VERB : "create" | "define" >
| < CREATION_VERB_3rd : "creates" | "defines" >
| < CONTROL_VERB : "check" | "verify" >
| < CONTROL_VERB_3rd : "checks" | "verifies" >
| < PRINT_VERB : "print" >
| < PRINT_VERB_3rd : "prints" >
| < RETURN_VERB : "returns" >
	//Functional connectors
| < CLASS_METHOD_CONNECTOR : "."  >			//N0 connector. ClassToClass, ClassToMethod, MethodToMethod 
| < METHOD_STATEMENT_CONNECTOR : ":"  > 	//N1 connector. MethodToStatement. Will be optional
| < LIST_CONNECTOR: (",") >					//N2 connector. VariableToVariable, ParameterToParamenter
| < STATEMENT_CONNECTOR : ";" >				//N3 connector. StatementToStatement
	//Operators
| < SYMBOLIC_EQUALS : "=" >
| < LANGUAGE_EQUALS : "equals" >
	//Other Tokens
| < DOT_NOTATION: "->" >
| < A_THE : "a" | "the" | "an" >
| < TO  : "to" >
| < IN  : "in" >
	//Auxiliar connector (not needed), might not be used
| < AUX_CONNECTOR : ("in" "addition") | "also" >
}

/* __ COMPLEX TOKENS __ */

TOKEN :
{
  	//Subjects 			// ====== CHANGED ====== // 
  < SUBJECT : (< I_SUBJECT > | < NORMAL_SUBJECT >) >
| < SUBJECT_3 : (< THRD_SUBJECT > | < OTHER_SUBJECT >) >
	//Comparison		// ====== CHANGED ====== // -- A comparator is to be used in any comparison situation. No other token must be used
| < COMPARATOR : ( < IS > < COMPARISON_EXPRESSIONS > < THAN > ) | ( < COMPARISON_SYMBOLS > ) >
	//Operation 		// ====== CHANGED ====== // -- An operator is to be used in any operation situation. No other token must be used
| < OPERATOR: (< OPERATION_EXPRESSION >|< OPERATION_SYMBOL >) >
	//Unary Operation 	// ====== CHANGED ====== // -- An unary operator is to be used in any unary operation situation. No other token must be used
| <UNARY_OPERATOR: (< UNARY_OPERATION_EXPRESSION >|< UNARY_OPERATION_SYMBOL >) >
	//Linkers			// ====== CHANGED ====== // -- A linker is to be used in any union situation (And, Or). No other token must be used
| < LINKER: (< LINKER_EXPRESSION >|< LINKER_SYMBOL >) >
	//Identifiers
| < CLASS_ID: <CAP_LETTER> (<ID_ANY>)* >
| < ID : <ID_BEGIN> (<ID_ANY>)* >
	//Constant
| < CONSTANT : (< DIGIT >)+ >
}

/* __ COMPLEX TOKENS ADDED FROM THE GRAMMAR __ *///This might clarify the syntactical analyzer

TOKEN:
{
  < PACKAGE_STATEMENT: (< PACKAGE_MOD >< CLASS_ID >< STATEMENT_CONNECTOR >) > //STATEMENT_CONNECTOR is ";" if there is any problem it can be changed
  // IMPORT FUNCTION HAS BEEN DISABLED
  < VISIBILITY: (< PUBLIC >|< PRIVATE >|< PROTECTED >) >
  }

TOKEN: /*Complex Meta Tokens, for the special Tokens, Comparator, Operator and Linker*/
{
 	//Language Comparison 	  < #COMPARISON_EXPRESSION : < LANGUAGE_EQUALS_COMPARISON >|(< LANGUAGE_COMPARISON > (< LANGUAGE_OR >< LANGAUGE_EQUALS_COMPARISON >)? )>
| < #LANGUAGE_EQUALS_COMPARISON : (< LANGUAGE_EQUALS > | < LANGUAGE_NOT ><LANGUAGE_EQUALS > )
| < #LANGUAGE_COMPARISSON : (< LANGUAGE_GREATER >|< LANGUAGE_SMALLER > ) >
	//Symbol Comparison
| < #COMPARISON_SYMBOLS: < SYMBOLIC_EQUALS_COMPARISON >|(< SYMBOLIC_COMPARISON > (< LANGUAGE_EQUALS_COMPARISON >)?) >
| < #SYMBOLIC_EQUALS_COMPARISON: (< SYMBOLIC_EQUALS >|< SYMBOLIC_NOT ><SYMBOLIC_EQUALS >) >
| < #SYMBOLIC_COMPARISON: (< SYBOLIC_GREATER >|< SYMBOLIC_SMALLER >) >
	//Operations
| < #OPERATION_EXPRESSION: (< LANGUAGE_PLUS >|< LANGUAGE_MINUS >|< LANGUAGE_TIMES >|< LANGUAGE_DIVIDES >) >
| < #OPERATION_SYMBOL: (< SYMBOLIC_PLUS >|< SYMBOLIC_MINUS >|< SYMBOLIC_TIMES >|< SYMBOLIC_DIVIDES >) >
	//Unary Operation
| < #UNARY_OPERATION_EXPRESSION: (< LANGUAGE_INCREMENT >|< LANGUAGE_DECREMENT >) >
| < #UNARY_OPERATION_SYMBOL: (< SYMBOLIC_INCREMENT >|< SYMBOLIC_DECREMENT >) >
	//Linker
| < #LINKER_EXPRESSION: (< LANGUAGE_AND >|< LANGUAGE_OR >) >
| < #LINKER_SYMBOL: (< SYMBOLIC_AND >|< SYMBOLIC_OR >) >
}

TOKEN [IGNORE_CASE] : /* Meta Tokens - Ignore Case */ /* EXTENSIBLE */
{
  	//Language Comparators
  < #LANGUAGE_NOT : "not" >
| < #LANGUAGE_GREATER : "greater" >
| < #LANGUAGE_SMALLER : "smaller" >
  	//Symbolic Comparators -- 
| < #SYMBOLIC_NOT : "!" >
| < #SYMBOLIC_GREATER : ">" >
| < #SYMBOLIC_SMALLER : "<" >
	//Language Operators
| < #LANGUAGE_MINUS : "minus" >
| < #LANGUAGE_PLUS : "plus" >
| < #LANGUAGE_TIMES : "times" >
| < #LANGUAGE_DIVIDES : "divides" >
	//Symbolic Operators
| < #SYMBOLIC_MINUS : "-" >
| < #SYMBOLIC_PLUS : "+" >
| < #SYMBOLIC_TIMES : "*" >
| < #SYMBOLIC_DIVIDES : "/" >
	//Language Unary Operators
| < #LANGUAGE_INCREMENT: "increment" >
| < #LANGUAGE_DECREMENT: "decrement" >
	//Symbolic Unary Operators
| < #SYMBOLIC_DECREMENT:"--" >
| < #SYMBOLIC_INCREMENT:"++" >
	//Language Linkers
| < #LANGUAGE_AND : "and" >
| < #LANGUAGE_OR : "or" >
	//Symbolic Linkers
| < #SYMBOLIC_OR : "||" >
| < #SYMBOLIC_AND: "&&" >
  	//Subject
| < #NORMAL_SUBJECT : ("you" | "we" | "they") >
| < #THRD_SUJBJECT : ("he" | "she" | "it" ) >
| < #OTHER_SUBJECT : < A_THE > ("program" | "computer" | "machine") >
	//Others
| < #IS  : "is" >
| < #THAN  : "than" >
//< #LANGUAGE_EQUALS : "equals" > Equals might be used by the syntactical analyzer
//< #SYMBOLIC_EQUALS : "=" > Equals might be used by the syntactical analyzer
	//Visibility
| < #PUBLIC_MOD : "public" >
| < #PRIVATE_MOD : "private" >
| < #PROTECTED_MOD : "protected" >
} 

TOKEN : /*Meta tokens*/
{
  	//First person subject
  < #I_SUBJECT : "I" >
	//Identifiers
	  	//Constant
| < #DIGIT : [ "0"-"9" ] >
| < #CAP_LETTER : ([ "A"-"Z" ]) >
| < #ID_BEGIN : ([ "a" - "z" ] | "$" | "_") >
| < #ID_ANY : (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "$" | "_" ) >

}

/* __ __ REMARKS & CHANGES __ __ */

/* __ SUBJECTS __ */
/* This is not necesary, it must be changed in the grammar*/
/* __ OPERATORS __ */
//this way of declaring the operators might be the solution for the LL(1) problem, it should also increase efficiency
//The syntactical analyzer only needs to call expression operator, logical operator or concatenation operator
//expression_operator(+,-,*,/,+=,-=,*=,/=, and any combination with natural language)
//logical_operator(<,>,=,!=,==,<=, >= and any combination with natural language)
//comparison_operator (||, &&, or)
//PARENTHESIS ARE NOT INCLUDED !!!!
/*It might be better that the syntactical analyzer is on charge of this part, allowing nested brackets*/
/* __ UNUSED TOKENS __*/
TOKEN [IGNORE_CASE] :
//{  
// <VALUE_OF : ("the" "value" "of") >// <ASSIGN : ( < SYMBOLIC_EQUALS > | < LANGUAGE_EQUALS >< TO > ) >
// <COMPLEX_OPERATION : "complex" "operation" >
//}
/*__ __ -------------------- __ __*/

/* __ -_-Syntactical Analyzer-_- __*/

/*
 *Prepares the grammar import and packages statements (Extracted from Java Grammar)
 * 
 * //compilation_unit : PACKAGE_STATEMENT? IMPORT_STATEMENT* TYPE_DECLARATION+
 *
 *IMPORT_STATEMENTS has been disabled for simplicity
 *
 *	("package" CLASS_ID ";")? class_declaration+
 */ 
void compilation_unit():{ if(this.verbose) System.out.println("Start compilation_unit"); }
{
  (< PACKAGE_STATEMENT >)? (class_declaration())+}

/*
 *	creation_sentence? ("public"|"private"|"protected")? ("final"|"abstract")? "class" CLASS_ID field_declaration+ "end-class"
 */
void class_declaration():{ if(this.verbose) System.out.println("Starts class_declaration");}{
  (creation_sentence())? (< VISIBILITY >)? (< FINAL_MOD >|<ABSTRACT_MOD >)? < CLASS > < CLASS_ID > (field_declaration())+ < END_CLASS >}
/*
 *	"." creation_sentence? ("public"|"private"|"protected")? ("static")? ("final")? (constructor_declaration | method_declaration | variable_declaration)
 */
void field_declaration():
{ if(this.verbose) System.out.println("Starts field_declaration");}
{
  < CLASS_METHOD_CONNECTOR > (creation_sentence())? (< VISIBILITY >)? (< STATIC_MOD >)? (< FINAL_MOD >)? (constructor_declaration() | method_declaration() | variable_declaration())
}    


%%
 





