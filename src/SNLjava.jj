/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
 options{  JDK_VERSION = "1.5";  static = true;}
PARSER_BEGIN(SNL)
public class SNL{
    public static void main(String args []) throws ParseException {
	if (args.length == 0) {
	    System.out.println("No input given");
	    //  SNL snlParser = new SNL(System.in);
	    return;
	}else if(args.length == 1){		System.out.println("Reading from file:" + args[0] + "...");
		try {
	    	SNL snlParser = new SNL(new java.io.FileInputStream(args[0]));
	    } catch (java.io.FileNotFoundException e) {
	    	System.out.println("The File " + args[0] + " has not been found");
	    	return;
	   	}
	} else {
	    System.out.println("Wrong number of parameters");
	    return;
	}

	//Parser begin
	
  }
}
/* Parser begin -EXAMPLE 1
	try {
      	parser.inicio();
      	parser.ReInit(new java.io.FileInputStream(args[0]));
      	parser.inicioSegundo();
		String archivo = args[0];
      	if(archivo.endsWith(".java"))
      		archivo = archivo.replace(".java","");
      	parser.generarCodigo(archivo+".as");
    	System.out.println("Completado parser");
    } catch (ParseException e) {
   		System.out.println("Errores"+ e.getMessage());
	} catch (java.io.FileNotFoundException e) {
		System.out.println("Fichero " + args[0] + " no encontrado");
		return;
	}
*/

/* Parser begin - EXAMPLE 2
	while (true){
	  System.out.println("Reading from standard input...");
	  System.out.println("Enter an expression in Structured Java Natual Language: ");
	  
	  try
	  {
	    switch (SNL.one_line())
	    {
	      case 0 : 
	      System.out.println("OK.");
	      break;
	      case 1 : 
	      System.out.println("Goodbye.");
	      break;
	      default : 
	      break;
	    }
	  }
	  catch (Exception e)
	  {
	    System.out.println("NOK.");
	    System.out.println(e.getMessage());
	    eg1.ReInit(System.in);
	  }
	  catch (Error e)
	  {
	    System.out.println("Oops.");
	    System.out.println(e.getMessage());
	    break;
	  }
	}
*/PARSER_END(SNL)SKIP :{  " " | "\r" | "\t" | "\n"}TOKEN : /*Meta tokens*/{  < CONSTANT : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}
/* __ GENERAL TOKENS __ */

/* __ JAVA TOKENS __*/

TOKEN : /* MODIFIERS */
{    < PACKAGE_MOD : "package" >
| < IMPORT_MOD : "import" >
| < PUBLIC_MOD : "public" >
| < PRIVATE_MOD : "private" >
| < PROTECTED_MOD : "protected" >
| < ABSTRACT_MOD : "abstract" >
| < STATIC_MOD : "static" >
| < FINAL_MOD : "final" >
| < EXTENDS_MOD : "extends" >
| < IMPLEMENTS_MOD : "implements" >
}

/* __ IDs __ */

TOKEN : /* IDENTIFIERS */
{  < CLASS_IDENTIFIER: <CAP_LETTER> (<ID_ANY>)* >
| < IDENTIFIER : <ID_BEGIN> (<ID_ANY>)* >
}

TOKEN : /* AUXILIAR TOKENS */
{  < #CAP_LETTER : ([ "A"-"Z" ]) >
| < #ID_BEGIN : ([ "a" - "z" ] | "$" | "_") >
| < #ID_ANY : (["a"-"z"] | ["A"-"Z"] | ["0"-"9"] | "$" | "_" ) >
}

/*__ SSNL TOKENS __*/

TOKEN [IGNORE_CASE] : /* BEGIN-END TOKENS */
{  
  < CLASS : "class" >
| < END_CLASS : "end-class" >
| < CONSTRUCTOR : "constructor" >
| < END_CONSTRUCTOR : "end-constructor" >
| < FUNCTION : ("function" | "method") >
| < END_FUNCTION: ("end-function" | "end-method") >
}

/* __ EXPRESSIONS __*/

TOKEN [IGNORE_CASE] : /* CONTROL - LOOP STATEMENTS */
{ <IF : "if" >
| < ELSE : "else" >
| < THEN : "then" | "then," >
| < END_IF : "end-if" >
| < WHILE : "while" >
| < END_WHILE: "end-while" >
}

TOKEN [IGNORE_CASE] : /* EXPRESSION CONSTANTS */
{  < INSTANCE_OF : "instance_of" >
| < NULL : "null" >
| < SUPER : "super" >
| < THIS : "this" >
| < NEW : "new" >
| < TRUE : "true" >
| < FALSE : "false" >
}

TOKEN [IGNORE_CASE] : /* TYPE NAMES */
{  < STRING : "string" >
| < CHAR : "char" >
| < BOOLEAN : "boolean" >
| < BYTE : "byte" >
| < SHORT : "short" >
| < INT : "int" >
| < LONG : "long" >
| < FLOAT : "float" >
| < DOUBLE : "double" >
}

TOKEN : /* ARRAY BRACKET LIST */
{	< ARRAY_TOKEN : ("[" "]")* >
}
 
/* __ NATURAL LANGUAGE RELATED TOKENS __ */

/* __ SUBJECTS __ */

TOKEN : /* SUBJECT TOKENS */
{  < CREATION_SUBJECT : (< SUBJECT >) >
| < CREATION_SUBJECT_3rd : (< SUBJECT_3 >) >
| < CONTROL_SUBJECT : (< SUBJECT >) >
| < CONTROL_SUBJECT_3rd : (< SUBJECT_3 >) >
| < PRINT_SUBJECT : (< SUBJECT >) >
| < PRINT_SUBJECT_3rd : (< SUBJECT_3 >) >
| < RETURN_SUBJECT : (< A_THE > "function") | "it" >
}

TOKEN :	/* SUBJECTS */
{  < SUBJECT : (< I_SUBJECT > | < NORMAL_SUBJECT >) >
| < SUBJECT_3 : (< THRD_SUBJECT > | < OTHER_SUBJECT >) >
}

TOKEN : /* "I" ONLY CAP LETTERS*/
{  < #I_SUBJECT : "I" >
}

TOKEN [IGNORE_CASE] : /* AUXILIAR SUBJECT TOKENS */ /* EXTENSIBLE */
{ < #NORMAL_SUBJECT : ("you" | "we" | "they") >
| < #THRD_SUJBJECT : ("he" | "she" | "it" ) >
| < #OTHER_SUBJECT : < A_THE > ("program" | "computer" | "machine") >
} 

/* __ VERBS __ */

TOKEN [IGNORE_CASE] : /* AUXILIAR VERBS */ /* EXTENSIBLE */
{  <AUX_VERB : "want" | "need" >
| <AUX_VERB_3rd : "wants" | "needs" >
| <MODAL_VERB : "shall" | "must" | "will" >
}

TOKEN [IGNORE_CASE] : /* ACTION VERBS */ /* EXTENSIBLE */
{ <ASSIGN_VERB : "save" | "store" >
| <ASSIGN_VERB_3rd : "saves" | "stores" >
| <CREATION_VERB : "create" | "define" >
| <CREATION_VERB_3rd : "creates" | "defines" >
| <CONTROL_VERB : "check" | "verify" >
| <CONTROL_VERB_3rd : "checks" | "verifies" >
| <PRINT_VERB : "print" >
| <PRINT_VERB_3rd : "prints" >
| <RETURN_VERB : "returns" >
}

/* __ CONNECTORS __ */

/* __ SNL LIKE __ */

TOKEN [IGNORE_CASE] : /* WORD CONNECTORS */
{
 <TO  : "to" >
| <IN  : "in" >
| <A_THE  : "a" | "an" | "the" >
}

/* __ FUNCTIONAL CONNECTORS __ */

TOKEN [IGNORE_CASE] : /* CONNECTORS */
{
  < CLASS_METHOD_CONNECTOR : "."  >			//N0 connector. ClassToClass, ClassToMethod, MethodToMethod 
| < METHOD_STATEMENT_CONNECTOR : ":"  > 	//N1 connector. MethodToStatement. Will be optional
| <LIST_CONNECTOR: ("," | "AND") >			//N2 connector. VariableToVariable, ParameterToParamenter
| < STATEMENT_CONNECTOR : ";" >				//N3 connector. StatementToStatement 
}

TOKEN [IGNORE_CASE] : /* AUXILIAR CONNECTORS */ /*might not be used*/
{
 <AUX_CONNECTOR : ("in" "addition") | "also" >
}

TOKEN [IGNORE_CASE] : /* VALUE OF */ /* NOT USED */
{  
 <VALUE_OF : ("the" "value" "of") >
}

/* __ EXPRESSIONS __ */

/* __ COMPARISON __ */

TOKEN : /* COMPARISON SENTENCE */
{
< COMPARE : ( < IS > < COMPARISON_EXPRESSIONS > < THAN > ) | ( < COMPARISON_SYMBOLS > ) >}

TOKEN [IGNORE_CASE] : /* COMPARISON AUXILIAR VERB*/
{
 <#IS  : "is" >
|  <#THAN  : "than" >
}


/* __ ASSIGN __*/

TOKEN : /* ASSIGN SENTENCE */ /* NOT USED */
{  < ASSIGN : ( < SYMBOLIC_EQUALS > | < LANGUAGE_EQUALS >< TO > ) >
} 

/* __ OPERATIONS __ */

TOKEN [IGNORE_CASE] : /* COMPLEX OPERATION EXPRESSION*/ /* NOT USED */
{ 
 <COMPLEX_OPERATION : "complex" "operation" >
}

/* __ OPERATORS __ */

//this way of declaring the operators might be the solution for the LL(1) problem, it should also increase efficiency
//The syntactical analyzer only needs to call expression operator, logical operator or concatenation operator
//expression_operator(+,-,*,/,+=,-=,*=,/=, and any combination with natural language)
//logical_operator(<,>,=,!=,==,<=, >= and any combination with natural language)
//comparison_operator (||, &&, or)
//PARENTHESIS ARE NOT INCLUDED !!!!

/*It might be better that the syntactical analyzer is on charge of this part, allowing nested brackets*/

TOKEN: /*OPERATORS*//*===CHANGED===*//*+++!LL(1)+++*/
//{//< EXPRESSION_OPERATOR: (< DOUBLE_EXPRESSION_OPERATOR >|< UNARY_EXPRESSION_OPERATOR >) >
//| <LOGICAL_OPERATOR: (< DOUBLE_LOGICAL_OPERATOR >|< UNARY_LOGICAL_OPERATOR >) >
//| < COMPARISON_OPERATOR(< OR >|< AND >) > 	// AND has not jet a language token
//}

TOKEN: /* CALCULATION EXPRESSION *//*===CHANGED====*//*+++!LL(1)+++*/ 
//{//< DOUBLE_EXPRESSION_OPERATOR: (< UNARY_EXPRESSION_OPERATOR > <EQUAL >) >
//| < UNARY_EXPRESSION_OPERATOR: (< MINUS >|< PLUS >|< TIMES >|< DIVIDES >) >
//}

TOKEN: /* LOGICAL EXPRESSION *//*===CHANGED===*//*+++!LL(1)+++*/ 
//{//< DOUBLE_LOGICAL_OPERATOR:((< EQUAL >|< NOT >|< UNARY_LOGICAL_OPERATOR >) < EQUAL >) //NOT is not standallone token, EQUAL is not standallone as a logical expression
//| <UNARY_LOGICAL_OPERATOR:(< GREATER >|< SMALLER >) >
//}

/* __ UNIVERSAL UNARY OPERATORS __ */

TOKEN [IGNORE_CASE]: /* UNARY OPERATORS DEFINITION *//*===CHANGED===*//*+++LL(1)DANGER++*/
//{
// < MINUS: (< SYMBOLIC_MINUS >|< LANGUAGE_MINUS >) >
//|  < PLUS: (< SYMBOLIC_PLUS >|< LANGUAGE_PLUS >) >
//|  < TIMES: (< SYMBOLIC_TIMES >|<LANGUAGE_TIMES >) >
//|  < DIVIDES: (< SYMBOLIC_DIVIDES >|<LANGUAGE_DIVIDES >) >
//|  < NOT: (< SYMBOLIC_NOT >|<LANGUAGE_NOT >) > 
//|  < EQUALS: (< SYMBOLIC_EQUALS >|<LANGUAGE_EQUALS >) >
//|  < GREATER:  (< SYMBOLIC_GREATER >|<LANGUAGE_GREATER >) >
//|  < SMALLER:  (< SYMBOLIC_SMALLER >|<LANGUAGE_SMALLER >) >//|  < OR: (< SYMBOLIC_OR >|<LANGUAGE_OR >) >
//|  < AND: (< SYMBOLIC_AND >) > //LANGUAGE AND MIGHT BE ADDED IN FUTURE
//}

/*----------------------------------*/


/* __ SPECIFIC UNARY OPERATORS __ */

TOKEN [IGNORE_CASE]: /*UNARY SYMBOLS AND NL WORDS*/ /*+++LL(1)DANGER+++*//*+++SEMANTIC DANGER+++*/
{  <#SYMBOLIC_MINUS : "-" > | <#LANGUAGE_MINUS : "minus" >
| <#SYMBOLIC_PLUS : "+" > | <#LANGUAGE_PLUS : "plus" >
| <#SYMBOLIC_TIMES : "*" > | <#LANGUAGE_TIMES : "times" >
| <#SYMBOLIC_DIVIDES : "/" > | <#LANGUAGE_DIVIDES : "divides" >
| <#SYMBOLIC_NOT : "!" > | <#LANGUAGE_NOT : "not" >
| <#SYMBOLIC_EQUALS : "=" > | <#LANGUAGE_EQUALS : "equals" >
| <#SYMBOLIC_GREATER : ">" > | <#LANGUAGE_GREATER : "greater" >
| <#SYMBOLIC_SMALLER : "<" > | <#LANGUAGE_SMALLER : "smaller" >
| <#SYMBOLIC_OR : "||" > | <#LANGUAGE_OR : "or" >
| <#SYMBOLIC_AND: "&&" >
| <#LANGUAGE_NUMERIC_INCREMENT: "increment" >
| <#LANGUAGE_NUMERIC_DECREMENT: "decrement" >
}

/* __ OTHER TOKENS __*/

TOKEN [IGNORE_CASE]:
{< VARIABLE : ("variable" |"variables") >
}

TOKEN [IGNORE_CASE]:
{ < DOT_NOTATION: "->" > 
}

TOKEN [IGNORE_CASE]: /* A, THE, AN */
{
 < A_THE : "a" | "the" | "an" >
}

%%
 





